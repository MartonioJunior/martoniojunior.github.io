<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Arts, Blueprints, Code!</title><description>Talking the ABC of Programming, Game Dev, Design and more by MartÃ´nio Jr.</description><link>https://martoniojunior.github.io</link><language>en</language><lastBuildDate>Thu, 18 Sep 2025 14:06:48 -0300</lastBuildDate><pubDate>Thu, 18 Sep 2025 14:06:48 -0300</pubDate><ttl>250</ttl><atom:link href="https://martoniojunior.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://martoniojunior.github.io/posts/ramblings/2025-09-18</guid><title>RSS is so Cool...</title><description>...and why this website exists.</description><link>https://martoniojunior.github.io/posts/ramblings/2025-09-18</link><pubDate>Thu, 18 Sep 2025 14:00:49 -0300</pubDate><content:encoded><![CDATA[<p>I sometimes wish I had known more about RSS sooner... Before, I used to check a select few websites a day and always get lost in what I've already seen or not. If I wanted to keep up-to-date on something, I'd either subscribe to a newsletter they require me to put my email on, an app that just crammed ads and unrelated content or I had to store URLs of relevant tools in a note system of some kind.</p><p>I'm also someone who doesn't really care or is interested about Social Media, even long before things went south: it's a stressful place where you're just fed more and more content to engage, react with very little time to think or reflect and it may not even be stuff you were looking for in the first place or want to see, pushed by recommendation algorithms that one may not be in control of.</p><p>It's also a bad place to make meaningful content: it's a global square where everyone is shouting over each other, either through a never-ending pressure for more likes, more views and more engagement to be relevant, all with context collapse, constant judgement and social pressures in conversations that maybe shouldn't be public to begin with.</p><p>You don't even have ownership over your account, your feed and what you write on it. Plus, if you try to leave due to a deteriorating service or due to exploitation from the company managing it, you have to start from scratch if you move to another place (unless you're already on a Federated Social Media).</p><p>I decided to check RSS out after discovering the specification a while back and ever since then I...</p><ul><li>Read any source I want, whenever I decide, with zero hurry to read them.</li><li>Follow more places than ever in whatever topics I'm interested in, even on Social Media like Bluesky and Mastodon!</li><li>Look for RSS feeds whenever I see a well-crafted and interesting blog post, even if the topic is adjacent to something I care.</li><li>Deal with less and less ads, clickbait, reactive posts and content I'm not interested in reading or watching.</li><li>Reduce the number of distractions I have to deal with while reading.</li><li>Know there's an end to the content and I can do other stuff.</li><li>Feel safe knowing that I'm not locked to any reader and that I can transfer the feeds I follow somewhere else or even share with others.</li></ul><p>Most important of all: I'm the one who chooses when and how all of above happens: it's not like I don't engage with recommendation algorithms, but whether I want to engage on it or not, it's an intentional decision that has a purpose and an intent.</p><blockquote><p>Did you know that this website has an RSS feed as well? Subscribe to it and get more ramblings like this one... ðŸ˜‰</p></blockquote><p>I was considering writing technical content in a platform like Medium to share knowledge, but as I read more and more people I followed talk explicitly about the advantages of making your own website, I decided to give it a try.</p><p>"But doesn't it feel like you're sometimes shouting at a void writing here instead of <em>insert random Social Media platform here</em> since you don't know how many people read and/or liked it?" Yes! But that's precisely what caused me to make one: free from the obligation of time tables (this post is out 2 weeks after the last one), I only reach the ones who actually wants to read my stuff, I own my content, there's no noise to deal with, I choose when and how I post and there's less pressure for me to write, making it easier for me to enjoy doing it (which, in turn, leads to better content overall).</p><p>Overall, RSS is an old-school approach that requires curation and a different mind as how you approach using it as both a reader and a writer, but one that has aged like fine wine and is well worth checking out in 2025.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://martoniojunior.github.io/posts/swift/foundation/units-and-measurements</guid><title>Swift Foundation's Units and Measurements</title><description>A deep-dive in some advantages and limitations of the Measurement API as it currently exists</description><link>https://martoniojunior.github.io/posts/swift/foundation/units-and-measurements</link><pubDate>Thu, 4 Sep 2025 14:00:21 -0300</pubDate><content:encoded><![CDATA[<h2>Introduction</h2><p>When developing in Swift for Apple platforms, <a href="https://developer.apple.com/documentation/foundation">Foundation</a> provides an out-of-the-box implementation for units and measurements, defining a set of physical dimensions that allows for conversion between units and offers formatting for measurements based on precision and rounding of numbers, level of detail, locale, and usage.</p><p>The <a href="https://developer.apple.com/documentation/foundation/units-and-measurement">Measurement API</a> has already been covered at length in many different places on the Internet, so I recommend the following links if you want an introduction on how to use Units and Measurements as they exist today:</p><ul><li><a href="https://fatbobman.com/en/posts/a-complete-guide-to-swift-measurement/">Fatbobman's article</a> presents a really great overview on the API and all of it's features with great code snippets, as well as an example of how to format measurements for use in SwiftUI.</li><li><a href="https://www.youtube.com/watch?v=tXbYO5MGjYU">Stewart Lynch's video</a> provides a more step-by-step tutorial on how to use the Measurement API and it's features if you're looking for a more code-along approach.</li><li><a href="https://troz.net/post/2025/swift-measurements/">TrozWare's article</a> focuses more on the <code>MeasurementFormatter</code> type to customize the display of a <code>Measurement</code> on Apple Watch.<ul><li>You can also check out this <a href="https://goshdarnformatstyle.com/measurement-style/">guide</a> documenting the formatting options available for Measurements.</li></ul></li></ul><p>This post focuses on the advantages and limitations of the current approach available in Foundation and how some architectural tweaks and modern Swift features could make it more flexible, stable and easier to use.</p><p>As of this post's writing, it's code does not have a pure Swift implementation yet, being exclusive to Apple platforms and <a href="https://github.com/swiftlang/swift-foundation">swift-foundation</a> only offering stubs to allow Swift code using it to compile in other platforms. Discussion on the implementation is already underway on <a href="https://forums.swift.org/t/measurement-dimension-and-unit/64649">Swift forums</a>, but since it's been stagnant since July 2023, so I hope this post can help anyone who's either looking to contribute in the discussion or looking to make their own Measurement package.</p><h2>What already works well?</h2><p>As a built-in structure of Swift Foundation, the Measurement API already reduces a lot of the work you're required to do in order to start using measures in your apps.</p><h3>Type-safe Unit Definition and Conversion</h3><p><code>Measurement&lt;UnitType&gt;</code> is a struct that associates a numeric value with an unit that represents the quantity measured, indicating the domain it belongs to.</p><p>This offers a type-safe approach for assigning values that is enforced by the compiler as shown in the example below, which requires that the measurement uses a unit of length.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> distance: <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;

distance <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(<span class="hljs-number">22</span>, <span class="hljs-type">UnitLength</span>.meters) <span class="hljs-comment">// âœ…</span>
distance <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(<span class="hljs-number">31</span>, <span class="hljs-type">UnitMass</span>.grams) <span class="hljs-comment">// ðŸ›‘ Cannot convert value of type &#x27;UnitMass&#x27; to expected argument type &#x27;UnitLength&#x27;</span>
</code></pre><p>The same applies for unit conversions, in which units conforming to the <code>Dimension</code> type can only convert to units in the same domain.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> weight <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">52</span>, unit: <span class="hljs-type">UnitMass</span>.kilograms)
weight.converted(to: .grams) <span class="hljs-comment">// âœ… 52_000 g</span>
weight.converted(to: .liters) <span class="hljs-comment">// ðŸ›‘ Type &#x27;UnitMass&#x27; has no member &#x27;liters&#x27;</span>
</code></pre><h3>Easy Extensibility</h3><p>Given their origins as Objective-C types, <code>Unit</code> and <code>Dimension</code> are abstract classes used as the base for the unit systems, implementing new unit types or dimensions via subclassing.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Amount</span>: <span class="hljs-title class_ inherited__">Dimension</span>, @unchecked <span class="hljs-title class_ inherited__">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> units: <span class="hljs-keyword">Self</span> { .<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;u&quot;</span>) }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Force</span>: <span class="hljs-title class_ inherited__">Dimension</span>, @unchecked <span class="hljs-title class_ inherited__">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> newtons: <span class="hljs-keyword">Self</span> { .<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;N&quot;</span>) }
}
</code></pre><p>And, through the use of extensions, you can also add brand new units like shown above, but also create entirely new units, being specifically useful when your app or game has a custom set of context-relevant units to measure it's information.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">extension</span> <span class="hljs-title class_">UnitLength</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> gizaPyramids: <span class="hljs-keyword">Self</span> {
		.<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;â—¢â—£&quot;</span>, converter: <span class="hljs-type">UnitConverterLinear</span>(coefficient: <span class="hljs-number">146.6</span>, constant: <span class="hljs-number">0</span>))
	}
}
</code></pre><h3>Formatting and Display</h3><p>When you want to display a measure, Foundation automatically formats your unit based on the device's settings (locale, metric system, etc.). You can also configure it's display format through the <code>formatted()</code> instance method on <code>Measurement</code>, which uses a DotSyntax <code>.measurement</code> to create an instance of <code>FormatStyle</code> dedicated to the Measurement API:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> volume <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">10</span>, unit: <span class="hljs-type">UnitVolume</span>.cubicFeet)
volume.formatted() <span class="hljs-comment">// &quot;283.168 cmÂ³&quot;</span>
volume.formatted(.measurement(width: .wide)) <span class="hljs-comment">// &quot;283.168 cubic centimetres&quot;</span>
volume.formatted(.measurement(width: .narrow, usage: .asProvided)) <span class="hljs-comment">// 10ftÂ³&quot;</span>
volume.formatted(.measurement(width: .abbreviated, usage: .liquid, numberFormatStyle: .number)) <span class="hljs-comment">// &quot;283 l&quot;</span>
</code></pre><h3>Wide Assortment of Default Units</h3><p>By default, Foundation provides over 22 specializations of <code>Unit</code> and/or <code>Dimension</code> (which amounts to over 200 predefined units), all with included formatting and display options for select unit types.</p><blockquote><p>ðŸ”® <strong>Fun Fact</strong>: As of writing, the most recent unit added to the Measurement API is <a href="https://developer.apple.com/documentation/foundation/unitenergy/energykit/milliwatthours">milliwattHours</a>, a unit of energy added in OS 26 and meant for use with the brand new <a href="https://developer.apple.com/documentation/EnergyKit">EnergyKit</a>... yet the unit is not available for watchOS, tvOS or visionOS and has it's own subtype inside of <code>UnitEnergy</code> (<code>UnitEnergy.EnergyKit</code>)</p></blockquote><p>This gives developers an out-of-the-box solution for most use cases that a traditional app would require. Add this with the easy extensibility for new and existing unit types and you have an API that's user-friendly, battle-tested and well designed for most developer needs.</p><p>Except...</p><h2>Limitations</h2><p>Well, as mentioned in the description of this post, there are some limitations that make the Measurement API not reach it's full intended potential when looking at it from the perspective of a Swift package.</p><h3>Objective-C constraints</h3><p>The current implementation in Swift is a Objective-C implementation into the language, sharing the same logic as the original module: with this, comes some important considerations before using it.</p><p>For starters, there's no compile-time enforcement stopping you from instancing <code>Unit</code> and <code>Dimension</code> objects in your code, or using them as <code>Measurement</code> filters, completely breaking the type-safety of the generic type. For example, the snippet below compiles and runs just fine with no errors:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> generalMeasurement <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">32</span>, unit: <span class="hljs-type">Unit</span>(symbol: <span class="hljs-string">&quot;#&quot;</span>))
generalMeasurement <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">22</span>, unit: <span class="hljs-type">UnitArea</span>.ares)
generalMeasurement <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">89</span>, unit: <span class="hljs-type">UnitInformationStorage</span>.bits)
</code></pre><p>You could even attempt to encode and decode the measurement under a generic measurement:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> gameSize <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">40</span>, unit: <span class="hljs-type">UnitInformationStorage</span>.bits)
<span class="hljs-keyword">let</span> encoded <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONEncoder</span>().encode(gameSize)
<span class="hljs-keyword">var</span> decoded <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitInformationStorage</span>&gt;.<span class="hljs-keyword">self</span>, from: encoded)
decoded <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">20</span>, unit: <span class="hljs-type">UnitPower</span>.watts) <span class="hljs-comment">// ðŸ›‘ Cannot convert value of type &#x27;UnitPower&#x27; to expected argument type &#x27;UnitInformationStorage&#x27;</span>
<span class="hljs-keyword">var</span> decodedWithGeneric <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;.<span class="hljs-keyword">self</span>, from: encoded)
decodedWithGeneric <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">20</span>, unit: <span class="hljs-type">UnitPower</span>.watts)
</code></pre><p>This could also lead to crashes at runtime, as the compiler's type inference isn't able to identify that these are two different types of <code>Measurement</code>, with the code below compiling just fine and presenting an error at runtime:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> path <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">32</span>, unit: <span class="hljs-type">UnitLength</span>.kilometers)
<span class="hljs-keyword">var</span> surface <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">21</span>, unit: <span class="hljs-type">UnitArea</span>.squareMiles)
path <span class="hljs-operator">&lt;</span> surface <span class="hljs-comment">// ðŸ›‘ Fatal error: Attempt to compare measurements with non-equal dimensions</span>
</code></pre><p>Even when accounting for <code>Comparable</code> and rewriting as <code>Measurement&lt;Unit&gt;</code> instances provides the same results:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> path2 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;(value: <span class="hljs-number">32</span>, unit: <span class="hljs-type">UnitLength</span>.kilometers)
<span class="hljs-keyword">var</span> surface2 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;(value: <span class="hljs-number">21</span>, unit: <span class="hljs-type">UnitArea</span>.squareMiles)
path2 <span class="hljs-operator">&lt;</span> surface2 <span class="hljs-comment">// ðŸ›‘ Fatal error: Attempt to compare measurements with non-equal dimensions</span>
</code></pre><p>Add in the Strict Concurrency Model, and even such a simple operation as this:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">func</span> <span class="hljs-title function_">someOperation</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">measurement</span>: <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;) -&gt; <span class="hljs-type">UnitLength</span> {
    <span class="hljs-keyword">return</span> measurement.unit
}

<span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">1.82</span>, unit: <span class="hljs-type">UnitLength</span>.meters)
<span class="hljs-keyword">let</span> outcome <span class="hljs-operator">=</span> someOperation(height) <span class="hljs-comment">// âœ… No issues</span>
</code></pre><p>Can have issues at runtime by adding a single <code>async</code>, even if the method has no suspend points:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">func</span> <span class="hljs-title function_">someOperation</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">measurement</span>: <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;) <span class="hljs-keyword">async</span> -&gt; <span class="hljs-type">UnitLength</span> {
    <span class="hljs-keyword">return</span> measurement.unit
}

<span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">1.82</span>, unit: <span class="hljs-type">UnitLength</span>.meters)
<span class="hljs-keyword">let</span> outcome <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> someOperation(height) <span class="hljs-comment">// ðŸ›‘ error: execution stopped with unexpected state.</span>
</code></pre><p>Even properly constraining the method to <code>@MainActor</code> as per requirement of a type inheriting from <code>NSObject</code> causes the same issue as above.</p><p>Dealing with an Objective-C class in Swift can be a very complex challenge already for developers with years of Swift experience given the Strict Concurrency requirements, so moving on to a pure Swift implementation in the future already will reduce many of the headaches listed above.</p><p>All of the above is temporary, up until a pure Swift implementation arrives, but there are some other things that</p><h3>Not SI compliant</h3><p>Another downside to the current implementation lies in it's default set of physical dimensions available, which does not encapsulate all SI units.</p><p>While there's 22 unit types provided with the package, only 5 of the 7 fundamental units are contemplated: Time (under <code>UnitDuration</code>). We also have a pretty big omission with Force not being an actual specialization in the package given it's pretty useful role in Physics operations, being the basis to compose other already implemented dimensions such as <code>UnitEnergy</code> and <code>UnitPressure</code>.</p><p>While the Measurement API has over 200 defined units, a sizeable number of them are just a redeclaration of the same unit under a different metric prefix and an adjusted converter to account for the new value. If we want any new unit system to follow SI's metric prefix conventions, we require to implement <strong><em>over 10 definitions per defined unit that we want to support Metric Prefixes on.</em></strong></p><blockquote><p>For reference, while <code>UnitInformationStorage</code> has by far the most amount of defined units in Foundation, the actual meaningful number of units for the domain are 3: <code>bit</code>, <code>nibble</code> and <code>byte</code>. This is due to the fact it not only implements SI's metric prefixes for <code>bit</code> and <code>byte</code>, but also a <a href="https://en.wikipedia.org/w/index.php?title=Binary_prefix">Binary Prefix</a>.</p></blockquote><h3>Restrictive API</h3><p>While the API is pretty robust and well-designed, there are some obstacles that could be patched up to provide a more accurate and flexible behaviour.</p><p>One example of this is when creating a <code>Measurement</code> instance: while <code>Measurement</code> accepts any <code>Double</code> value, there are cases where constraining the value to another type would allow for more accurate representation in context (e.g. describing a file size using <code>Int</code> or <code>Decimal</code> in order to avoid floating-point errors or provide discrete measurement of units).</p><p>While the API itself is pretty descriptive and easy to understand by reading the code, it can also become pretty verbose: creating a variable to store a measure of "2m" can require 54 characters in it's smallest, non-explicit form, as shown below:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">2</span>, unit: <span class="hljs-type">UnitLength</span>.meters)
</code></pre><p>Speaking of less-verbose syntax, another issue lies in the lack of DotSyntax support for units, which is a result of <code>Unit</code>, <code>Dimension</code> and it's inherited types defined in the packages being non-generic, non-<code>final</code> classes.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomLength</span>: <span class="hljs-title class_ inherited__">UnitLength</span>, @unchecked <span class="hljs-title class_ inherited__">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> palms: <span class="hljs-keyword">Self</span> { .<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;âœ‹&quot;</span>) }
}

<span class="hljs-keyword">let</span> failedDotSyntax1 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;(value: <span class="hljs-number">23</span>, unit: .palms) <span class="hljs-comment">// ðŸ›‘ Type &#x27;Unit&#x27; has no member &#x27;palms&#x27;</span>
<span class="hljs-keyword">let</span> failedDotSyntax2 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;(value: <span class="hljs-number">23</span>, unit: .palms) <span class="hljs-comment">// ðŸ›‘ Type &#x27;UnitLength&#x27; has no member &#x27;palms&#x27;</span>
<span class="hljs-keyword">let</span> validDotSyntax <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">CustomLength</span>&gt;(value: <span class="hljs-number">23</span>, unit: .palms) <span class="hljs-comment">// âœ… Success</span>
</code></pre><p>The implementation above still requires explicit declaration of generics, which limits the permisiveness of the notation.</p><p>Some other drawbacks include being unable to create ranges of measures with units conforming to <code>Dimension</code> and using a <code>UnitConverterLinear</code> and converting to derived units using the base operations (e.g. <code>Measurement&lt;UnitLength&gt;</code> * <code>Measurement&lt;UnitLength&gt;</code> = <code>Measurement&lt;UnitArea&gt;</code>).</p><p>There's probably more examples I could talk about, but overall the API has some areas of improvement so that it can become less diffuse, more visible and permissive.</p><h2>Conclusion</h2><p>As with any framework design, there's no absolutes on what is better and the current design of swift-foundation already is pretty great and works for most of use cases that a developer would need in their day-to-day, only requiring a pure Swift implementation to fix most of it's issues.</p><p>Due to ABI and source stability requirements it's unlikely that we'll see any big redesign to the current code as it is required to be compatible with the current Foundation. However, we can look into Swift packages made by the community for alternatives made with modern features in mind:</p><ul><li><a href="https://github.com/alexandrehsaad/swift-measures">swift-measures</a> is a very good reimplementation of the Measurement API that takes advantage of Swift features, such as structs, protocols and property wrappers. It also dips into new features like the composition of measures (e.g. Length / Time = Velocity) and adds in missing SI unit types such as Force, Magnetic Flux, Substance Amount and more.</li><li><a href="https://github.com/hyperjeff/Physical">Physical</a> goes for an unique approach: it builds on top of the current Foundation structure, composing units by chaining numbers with properties and mixing dimensions to create new ones using a base <code>Physical</code> protocol.</li><li><a href="https://github.com/NeedleInAJayStack/Units">Units</a> also follows a similar approach to the packages above, creating it's own implementation for composing units together, using a registry system to parse a measurement from a <code>String</code>. The package also provides a CLI tool for use in conversions.</li><li>Beyond these, I'm also working on my <a href="https://github.com/MartonioJunior/trinkets-swift">own implementation</a> of Units and Measurements for Game Development purposes, focusing more on ergonomy, type-safety, generics and other Modern Swift features (e.g. Integer Generic Parameters) to provide a more structured approach for units that aids experimentation and prevents bugs and misuses at compile time.</li></ul><p>At the end of the day, the best approach is the one that actually fits the requirements of your software, so choosing the right tool for the job (or even implementing your own based on existing solutions) is the way to go.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://martoniojunior.github.io/posts/welcome</guid><title>Welcome!</title><description>An introduction to the Arts, Blueprints, Code! website.</description><link>https://martoniojunior.github.io/posts/welcome</link><pubDate>Thu, 4 Sep 2025 12:59:05 -0300</pubDate><content:encoded><![CDATA[<p>Hello! This is my first post <s>testing if RSS is working correctly</s> welcoming you to the Arts, Blueprints, Code! website. This is my little big planet here on this vast world: a place for all the ideas, ramblings, thoughts, essays and whatever else the spark of creativity drives me to write, code, craft or experiment with.</p><blockquote><p>If you want to know more, check the <a href="https://martoniojunior.github.io/about/">About</a> page.</p></blockquote><p>I'm still working on some edges over time, but the content is already coming in, starting with my first post on <a href="https://martoniojunior.github.io/posts/swift/foundation/units-and-measurements">Units and Measurements in Swift Foundation today and how modern Swift could improve them</a>. While the first post is pretty meaty, I plan to have posts of many different sizes, covering a wide length of subjects.</p><p>If you want to follow along, subscribe to this website's <a href="https://martoniojunior.github.io/feed.rss">RSS Feed</a> to receive new posts as they are published and hope you enjoy them!</p><p>Junior</p>]]></content:encoded></item></channel></rss>
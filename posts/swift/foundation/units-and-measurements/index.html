<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Arts, Blueprints, Code!"/><link rel="canonical" href="https://martoniojunior.github.io/posts/swift/foundation/units-and-measurements"/><meta name="twitter:url" content="https://martoniojunior.github.io/posts/swift/foundation/units-and-measurements"/><meta property="og:url" content="https://martoniojunior.github.io/posts/swift/foundation/units-and-measurements"/><title>Swift Foundation's Units and Measurements | Arts, Blueprints, Code!</title><meta name="twitter:title" content="Swift Foundation's Units and Measurements | Arts, Blueprints, Code!"/><meta property="og:title" content="Swift Foundation's Units and Measurements | Arts, Blueprints, Code!"/><meta name="description" content="A deep-dive in some advantages and limitations of the Measurement API as it currently exists"/><meta name="twitter:description" content="A deep-dive in some advantages and limitations of the Measurement API as it currently exists"/><meta property="og:description" content="A deep-dive in some advantages and limitations of the Measurement API as it currently exists"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/EnergyTheme/styles.css" type="text/css"/><link rel="stylesheet" href="/EnergyTheme/code.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Arts, Blueprints, Code!"/></head><body class="post"><header><div class="wrapper"><a href="/" class="site-name">Arts, Blueprints, Code!</a><p class="description">Talking the ABC of Programming, Game Dev, Design and more by MartÃ´nio Jr.</p><p class="wip">Website still in development...</p><nav><ul><li class="selected"><a href="/posts">Posts</a></li><li><a href="/projects">Projects</a></li><li><a href="/artsCrafts">Arts and Crafts</a></li><li><a href="/web">Surfing the Web</a></li><li><a href="/about">About</a></li><li><a href="/contact">Contact</a></li></ul></nav></div></header><div class="wrapper"><article><h1>Swift Foundation's Units and Measurements</h1><p class="description">A deep-dive in some advantages and limitations of the Measurement API as it currently exists</p><div class="content"><h2>Introduction</h2><p>When developing in Swift for Apple platforms, <a href="https://developer.apple.com/documentation/foundation">Foundation</a> provides an out-of-the-box implementation for units and measurements, defining a set of physical dimensions that allows for conversion between units and offers formatting for measurements based on precision and rounding of numbers, level of detail, locale, and usage.</p><p>The <a href="https://developer.apple.com/documentation/foundation/units-and-measurement">Measurement API</a> has already been covered at length in many different places on the Internet, so I recommend the following links if you want an introduction on how to use Units and Measurements as they exist today:</p><ul><li><a href="https://fatbobman.com/en/posts/a-complete-guide-to-swift-measurement/">Fatbobman's article</a> presents a really great overview on the API and all of it's features with great code snippets, as well as an example of how to format measurements for use in SwiftUI.</li><li><a href="https://www.youtube.com/watch?v=tXbYO5MGjYU">Stewart Lynch's video</a> provides a more step-by-step tutorial on how to use the Measurement API and it's features if you're looking for a more code-along approach.</li><li><a href="https://troz.net/post/2025/swift-measurements/">TrozWare's article</a> focuses more on the <code>MeasurementFormatter</code> type to customize the display of a <code>Measurement</code> on Apple Watch.<ul><li>You can also check out this <a href="https://goshdarnformatstyle.com/measurement-style/">guide</a> documenting the formatting options available for Measurements.</li></ul></li></ul><p>This post focuses on the advantages and limitations of the current approach available in Foundation and how some architectural tweaks and modern Swift features could make it more flexible, stable and easier to use.</p><p>As of this post's writing, it's code does not have a pure Swift implementation yet, being exclusive to Apple platforms and <a href="https://github.com/swiftlang/swift-foundation">swift-foundation</a> only offering stubs to allow Swift code using it to compile in other platforms. Discussion on the implementation is already underway on <a href="https://forums.swift.org/t/measurement-dimension-and-unit/64649">Swift forums</a>, but since it's been stagnant since July 2023, so I hope this post can help anyone who's either looking to contribute in the discussion or looking to make their own Measurement package.</p><h2>What already works well?</h2><p>As a built-in structure of Swift Foundation, the Measurement API already reduces a lot of the work you're required to do in order to start using measures in your apps.</p><h3>Type-safe Unit Definition and Conversion</h3><p><code>Measurement&lt;UnitType&gt;</code> is a struct that associates a numeric value with an unit that represents the quantity measured, indicating the domain it belongs to.</p><p>This offers a type-safe approach for assigning values that is enforced by the compiler as shown in the example below, which requires that the measurement uses a unit of length.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> distance: <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;

distance <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(<span class="hljs-number">22</span>, <span class="hljs-type">UnitLength</span>.meters) <span class="hljs-comment">// âœ…</span>
distance <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(<span class="hljs-number">31</span>, <span class="hljs-type">UnitMass</span>.grams) <span class="hljs-comment">// ðŸ›‘ Cannot convert value of type &#x27;UnitMass&#x27; to expected argument type &#x27;UnitLength&#x27;</span>
</code></pre><p>The same applies for unit conversions, in which units conforming to the <code>Dimension</code> type can only convert to units in the same domain.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> weight <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">52</span>, unit: <span class="hljs-type">UnitMass</span>.kilograms)
weight.converted(to: .grams) <span class="hljs-comment">// âœ… 52_000 g</span>
weight.converted(to: .liters) <span class="hljs-comment">// ðŸ›‘ Type &#x27;UnitMass&#x27; has no member &#x27;liters&#x27;</span>
</code></pre><h3>Easy Extensibility</h3><p>Given their origins as Objective-C types, <code>Unit</code> and <code>Dimension</code> are abstract classes used as the base for the unit systems, implementing new unit types or dimensions via subclassing.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Amount</span>: <span class="hljs-title class_ inherited__">Dimension</span>, @unchecked <span class="hljs-title class_ inherited__">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> units: <span class="hljs-keyword">Self</span> { .<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;u&quot;</span>) }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Force</span>: <span class="hljs-title class_ inherited__">Dimension</span>, @unchecked <span class="hljs-title class_ inherited__">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> newtons: <span class="hljs-keyword">Self</span> { .<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;N&quot;</span>) }
}
</code></pre><p>And, through the use of extensions, you can also add brand new units like shown above, but also create entirely new units, being specifically useful when your app or game has a custom set of context-relevant units to measure it's information.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">public</span> <span class="hljs-keyword">extension</span> <span class="hljs-title class_">UnitLength</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> gizaPyramids: <span class="hljs-keyword">Self</span> {
		.<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;â—¢â—£&quot;</span>, converter: <span class="hljs-type">UnitConverterLinear</span>(coefficient: <span class="hljs-number">146.6</span>, constant: <span class="hljs-number">0</span>))
	}
}
</code></pre><h3>Formatting and Display</h3><p>When you want to display a measure, Foundation automatically formats your unit based on the device's settings (locale, metric system, etc.). You can also configure it's display format through the <code>formatted()</code> instance method on <code>Measurement</code>, which uses a DotSyntax <code>.measurement</code> to create an instance of <code>FormatStyle</code> dedicated to the Measurement API:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">let</span> volume <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">10</span>, unit: <span class="hljs-type">UnitVolume</span>.cubicFeet)
volume.formatted() <span class="hljs-comment">// &quot;283.168 cmÂ³&quot;</span>
volume.formatted(.measurement(width: .wide)) <span class="hljs-comment">// &quot;283.168 cubic centimetres&quot;</span>
volume.formatted(.measurement(width: .narrow, usage: .asProvided)) <span class="hljs-comment">// 10ftÂ³&quot;</span>
volume.formatted(.measurement(width: .abbreviated, usage: .liquid, numberFormatStyle: .number)) <span class="hljs-comment">// &quot;283 l&quot;</span>
</code></pre><h3>Wide Assortment of Default Units</h3><p>By default, Foundation provides over 22 specializations of <code>Unit</code> and/or <code>Dimension</code> (which amounts to over 200 predefined units), all with included formatting and display options for select unit types.</p><blockquote><p>ðŸ”® <strong>Fun Fact</strong>: As of writing, the most recent unit added to the Measurement API is <a href="https://developer.apple.com/documentation/foundation/unitenergy/energykit/milliwatthours">milliwattHours</a>, a unit of energy added in OS 26 and meant for use with the brand new <a href="https://developer.apple.com/documentation/EnergyKit">EnergyKit</a>... yet the unit is not available for watchOS, tvOS or visionOS and has it's own subtype inside of <code>UnitEnergy</code> (<code>UnitEnergy.EnergyKit</code>)</p></blockquote><p>This gives developers an out-of-the-box solution for most use cases that a traditional app would require. Add this with the easy extensibility for new and existing unit types and you have an API that's user-friendly, battle-tested and well designed for most developer needs.</p><p>Except...</p><h2>Limitations</h2><p>Well, as mentioned in the description of this post, there are some limitations that make the Measurement API not reach it's full intended potential when looking at it from the perspective of a Swift package.</p><h3>Objective-C constraints</h3><p>The current implementation in Swift is a Objective-C implementation into the language, sharing the same logic as the original module: with this, comes some important considerations before using it.</p><p>For starters, there's no compile-time enforcement stopping you from instancing <code>Unit</code> and <code>Dimension</code> objects in your code, or using them as <code>Measurement</code> filters, completely breaking the type-safety of the generic type. For example, the snippet below compiles and runs just fine with no errors:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> generalMeasurement <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">32</span>, unit: <span class="hljs-type">Unit</span>(symbol: <span class="hljs-string">&quot;#&quot;</span>))
generalMeasurement <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">22</span>, unit: <span class="hljs-type">UnitArea</span>.ares)
generalMeasurement <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">89</span>, unit: <span class="hljs-type">UnitInformationStorage</span>.bits)
</code></pre><p>You could even attempt to encode and decode the measurement under a generic measurement:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> gameSize <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">40</span>, unit: <span class="hljs-type">UnitInformationStorage</span>.bits)
<span class="hljs-keyword">let</span> encoded <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONEncoder</span>().encode(gameSize)
<span class="hljs-keyword">var</span> decoded <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitInformationStorage</span>&gt;.<span class="hljs-keyword">self</span>, from: encoded)
decoded <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">20</span>, unit: <span class="hljs-type">UnitPower</span>.watts) <span class="hljs-comment">// ðŸ›‘ Cannot convert value of type &#x27;UnitPower&#x27; to expected argument type &#x27;UnitInformationStorage&#x27;</span>
<span class="hljs-keyword">var</span> decodedWithGeneric <span class="hljs-operator">=</span> <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;.<span class="hljs-keyword">self</span>, from: encoded)
decodedWithGeneric <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">20</span>, unit: <span class="hljs-type">UnitPower</span>.watts)
</code></pre><p>This could also lead to crashes at runtime, as the compiler's type inference isn't able to identify that these are two different types of <code>Measurement</code>, with the code below compiling just fine and presenting an error at runtime:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> path <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">32</span>, unit: <span class="hljs-type">UnitLength</span>.kilometers)
<span class="hljs-keyword">var</span> surface <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">21</span>, unit: <span class="hljs-type">UnitArea</span>.squareMiles)
path <span class="hljs-operator">&lt;</span> surface <span class="hljs-comment">// ðŸ›‘ Fatal error: Attempt to compare measurements with non-equal dimensions</span>
</code></pre><p>Even when accounting for <code>Comparable</code> and rewriting as <code>Measurement&lt;Unit&gt;</code> instances provides the same results:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> path2 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;(value: <span class="hljs-number">32</span>, unit: <span class="hljs-type">UnitLength</span>.kilometers)
<span class="hljs-keyword">var</span> surface2 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;(value: <span class="hljs-number">21</span>, unit: <span class="hljs-type">UnitArea</span>.squareMiles)
path2 <span class="hljs-operator">&lt;</span> surface2 <span class="hljs-comment">// ðŸ›‘ Fatal error: Attempt to compare measurements with non-equal dimensions</span>
</code></pre><p>Add in the Strict Concurrency Model, and even such a simple operation as this:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">func</span> <span class="hljs-title function_">someOperation</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">measurement</span>: <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;) -&gt; <span class="hljs-type">UnitLength</span> {
    <span class="hljs-keyword">return</span> measurement.unit
}

<span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">1.82</span>, unit: <span class="hljs-type">UnitLength</span>.meters)
<span class="hljs-keyword">let</span> outcome <span class="hljs-operator">=</span> someOperation(height) <span class="hljs-comment">// âœ… No issues</span>
</code></pre><p>Can have issues at runtime by adding a single <code>async</code>, even if the method has no suspend points:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">func</span> <span class="hljs-title function_">someOperation</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">measurement</span>: <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;) <span class="hljs-keyword">async</span> -&gt; <span class="hljs-type">UnitLength</span> {
    <span class="hljs-keyword">return</span> measurement.unit
}

<span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">1.82</span>, unit: <span class="hljs-type">UnitLength</span>.meters)
<span class="hljs-keyword">let</span> outcome <span class="hljs-operator">=</span> <span class="hljs-keyword">await</span> someOperation(height) <span class="hljs-comment">// ðŸ›‘ error: execution stopped with unexpected state.</span>
</code></pre><p>Even properly constraining the method to <code>@MainActor</code> as per requirement of a type inheriting from <code>NSObject</code> causes the same issue as above.</p><p>Dealing with an Objective-C class in Swift can be a very complex challenge already for developers with years of Swift experience given the Strict Concurrency requirements, so moving on to a pure Swift implementation in the future already will reduce many of the headaches listed above.</p><p>All of the above is temporary, up until a pure Swift implementation arrives, but there are some other things that</p><h3>Not SI compliant</h3><p>Another downside to the current implementation lies in it's default set of physical dimensions available, which does not encapsulate all SI units.</p><p>While there's 22 unit types provided with the package, only 5 of the 7 fundamental units are contemplated: Time (under <code>UnitDuration</code>). We also have a pretty big omission with Force not being an actual specialization in the package given it's pretty useful role in Physics operations, being the basis to compose other already implemented dimensions such as <code>UnitEnergy</code> and <code>UnitPressure</code>.</p><p>While the Measurement API has over 200 defined units, a sizeable number of them are just a redeclaration of the same unit under a different metric prefix and an adjusted converter to account for the new value. If we want any new unit system to follow SI's metric prefix conventions, we require to implement <strong><em>over 10 definitions per defined unit that we want to support Metric Prefixes on.</em></strong></p><blockquote><p>For reference, while <code>UnitInformationStorage</code> has by far the most amount of defined units in Foundation, the actual meaningful number of units for the domain are 3: <code>bit</code>, <code>nibble</code> and <code>byte</code>. This is due to the fact it not only implements SI's metric prefixes for <code>bit</code> and <code>byte</code>, but also a <a href="https://en.wikipedia.org/w/index.php?title=Binary_prefix">Binary Prefix</a>.</p></blockquote><h3>Restrictive API</h3><p>While the API is pretty robust and well-designed, there are some obstacles that could be patched up to provide a more accurate and flexible behaviour.</p><p>One example of this is when creating a <code>Measurement</code> instance: while <code>Measurement</code> accepts any <code>Double</code> value, there are cases where constraining the value to another type would allow for more accurate representation in context (e.g. describing a file size using <code>Int</code> or <code>Decimal</code> in order to avoid floating-point errors or provide discrete measurement of units).</p><p>While the API itself is pretty descriptive and easy to understand by reading the code, it can also become pretty verbose: creating a variable to store a measure of "2m" can require 54 characters in it's smallest, non-explicit form, as shown below:</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>(value: <span class="hljs-number">2</span>, unit: <span class="hljs-type">UnitLength</span>.meters)
</code></pre><p>Speaking of less-verbose syntax, another issue lies in the lack of DotSyntax support for units, which is a result of <code>Unit</code>, <code>Dimension</code> and it's inherited types defined in the packages being non-generic, non-<code>final</code> classes.</p><pre data-language="swift" class="hljs"><code><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomLength</span>: <span class="hljs-title class_ inherited__">UnitLength</span>, @unchecked <span class="hljs-title class_ inherited__">Sendable</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> palms: <span class="hljs-keyword">Self</span> { .<span class="hljs-keyword">init</span>(symbol: <span class="hljs-string">&quot;âœ‹&quot;</span>) }
}

<span class="hljs-keyword">let</span> failedDotSyntax1 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">Unit</span>&gt;(value: <span class="hljs-number">23</span>, unit: .palms) <span class="hljs-comment">// ðŸ›‘ Type &#x27;Unit&#x27; has no member &#x27;palms&#x27;</span>
<span class="hljs-keyword">let</span> failedDotSyntax2 <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">UnitLength</span>&gt;(value: <span class="hljs-number">23</span>, unit: .palms) <span class="hljs-comment">// ðŸ›‘ Type &#x27;UnitLength&#x27; has no member &#x27;palms&#x27;</span>
<span class="hljs-keyword">let</span> validDotSyntax <span class="hljs-operator">=</span> <span class="hljs-type">Measurement</span>&lt;<span class="hljs-type">CustomLength</span>&gt;(value: <span class="hljs-number">23</span>, unit: .palms) <span class="hljs-comment">// âœ… Success</span>
</code></pre><p>The implementation above still requires explicit declaration of generics, which limits the permisiveness of the notation.</p><p>Some other drawbacks include being unable to create ranges of measures with units conforming to <code>Dimension</code> and using a <code>UnitConverterLinear</code> and converting to derived units using the base operations (e.g. <code>Measurement&lt;UnitLength&gt;</code> * <code>Measurement&lt;UnitLength&gt;</code> = <code>Measurement&lt;UnitArea&gt;</code>).</p><p>There's probably more examples I could talk about, but overall the API has some areas of improvement so that it can become less diffuse, more visible and permissive.</p><h2>Conclusion</h2><p>As with any framework design, there's no absolutes on what is better and the current design of swift-foundation already is pretty great and works for most of use cases that a developer would need in their day-to-day, only requiring a pure Swift implementation to fix most of it's issues.</p><p>Due to ABI and source stability requirements it's unlikely that we'll see any big redesign to the current code as it is required to be compatible with the current Foundation. However, we can look into Swift packages made by the community for alternatives made with modern features in mind:</p><ul><li><a href="https://github.com/alexandrehsaad/swift-measures">swift-measures</a> is a very good reimplementation of the Measurement API that takes advantage of Swift features, such as structs, protocols and property wrappers. It also dips into new features like the composition of measures (e.g. Length / Time = Velocity) and adds in missing SI unit types such as Force, Magnetic Flux, Substance Amount and more.</li><li><a href="https://github.com/hyperjeff/Physical">Physical</a> goes for an unique approach: it builds on top of the current Foundation structure, composing units by chaining numbers with properties and mixing dimensions to create new ones using a base <code>Physical</code> protocol.</li><li><a href="https://github.com/NeedleInAJayStack/Units">Units</a> also follows a similar approach to the packages above, creating it's own implementation for composing units together, using a registry system to parse a measurement from a <code>String</code>. The package also provides a CLI tool for use in conversions.</li><li>Beyond these, I'm also working on my <a href="https://github.com/MartonioJunior/trinkets-swift">own implementation</a> of Units and Measurements for Game Development purposes, focusing more on ergonomy, type-safety, generics and other Modern Swift features (e.g. Integer Generic Parameters) to provide a more structured approach for units that aids experimentation and prevents bugs and misuses at compile time.</li></ul><p>At the end of the day, the best approach is the one that actually fits the requirements of your software, so choosing the right tool for the job (or even implementing your own based on existing solutions) is the way to go.</p></div></article></div><footer><p>Â© 2025 MartÃ´nio JÃºnior</p><p>Website built in Swift using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS</a> | <a href="https://github.com/martoniojunior">Github</a></p></footer></body></html>
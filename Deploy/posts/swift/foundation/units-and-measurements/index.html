<!doctype html><html><head><title>Arts, Blueprints, Code!</title><meta charset="utf-8"><link type="text/css" rel="stylesheet" href="/Resources/EnergyTheme/styles.css"><link type="text/css" rel="stylesheet" href="/Resources/EnergyTheme/code.css"><style></style></head><body><header><div class="wrapper"><a class="site-name" href="/">Arts, Blueprints, Code!</a><p class="description">Talking the ABC of Programming, Game Dev, Design and more by Mart√¥nio Jr.</p><p class="wip">Website still in development...</p><nav><ul><li class><a href="/posts">Posts</a></li><li class><a href="/projects">Projects</a></li><li class><a href="/artsCrafts">Arts and Crafts</a></li><li class><a href="/web">Surfing the Web</a></li><li class><a href="/about">About</a></li><li class><a href="/contact">Contact</a></li></ul></nav></div></header><div class="wrapper"><article><h1>Swift Foundation's Units and Measurements</h1><p class="description">A deep-dive in some advantages and limitations of the Measurement API as it currently exists</p><p class="timestamps">Posted <time datetime="29/08/2025, 13:36">29 de ago. de 2025, 13:36</time>, Last Updated <time datetime="04/09/2025, 14:00">4 de set. de 2025, 14:00</time></p><div class="content"><h2>Introduction</h2>
<p>When developing in Swift for Apple platforms, <a href="https://developer.apple.com/documentation/foundation">Foundation</a> provides an out-of-the-box implementation for units and measurements, defining a set of physical dimensions that allows for conversion between units and offers formatting for measurements based on precision and rounding of numbers, level of detail, locale, and usage.</p>
<p>The <a href="https://developer.apple.com/documentation/foundation/units-and-measurement">Measurement API</a> has already been covered at length in many different places on the Internet, so I recommend the following links if you want an introduction on how to use Units and Measurements as they exist today:</p>
<ul>
<li><a href="https://fatbobman.com/en/posts/a-complete-guide-to-swift-measurement/">Fatbobman‚Äôs article</a> presents a really great overview on the API and all of it‚Äôs features with great code snippets, as well as an example of how to format measurements for use in SwiftUI.</li>
<li><a href="https://www.youtube.com/watch?v=tXbYO5MGjYU">Stewart Lynch‚Äôs video</a> provides a more step-by-step tutorial on how to use the Measurement API and it‚Äôs features if you‚Äôre looking for a more code-along approach.</li>
<li><a href="https://troz.net/post/2025/swift-measurements/">TrozWare‚Äôs article</a> focuses more on the <code>MeasurementFormatter</code> type to customize the display of a <code>Measurement</code> on Apple Watch.
<ul>
<li>You can also check out this <a href="https://goshdarnformatstyle.com/measurement-style/">guide</a> documenting the formatting options available for Measurements.</li>
</ul>
</li>
</ul>
<p>This post focuses on the advantages and limitations of the current approach available in Foundation and how some architectural tweaks and modern Swift features could make it more flexible, stable and easier to use.</p>
<p>As of this post‚Äôs writing, it‚Äôs code does not have a pure Swift implementation yet, being exclusive to Apple platforms and <a href="https://github.com/swiftlang/swift-foundation">swift-foundation</a> only offering stubs to allow Swift code using it to compile in other platforms. Discussion on the implementation is already underway on <a href="https://forums.swift.org/t/measurement-dimension-and-unit/64649">Swift forums</a>, but since it‚Äôs been stagnant since July 2023, so I hope this post can help anyone who‚Äôs either looking to contribute in the discussion or looking to make their own Measurement package.</p>
<h2>What already works well?</h2>
<p>As a built-in structure of Swift Foundation, the Measurement API already reduces a lot of the work you‚Äôre required to do in order to start using measures in your apps.</p>
<h3>Type-safe Unit Definition and Conversion</h3>
<p><code>Measurement&lt;UnitType&gt;</code> is a struct that associates a numeric value with an unit that represents the quantity measured, indicating the domain it belongs to.</p>
<p>This offers a type-safe approach for assigning values that is enforced by the compiler as shown in the example below, which requires that the measurement uses a unit of length.</p>
<pre><code class="language-swift">var distance: Measurement&lt;UnitLength&gt;

distance = Measurement(22, UnitLength.meters) // ‚úÖ
distance = Measurement(31, UnitMass.grams) // üõë Cannot convert value of type 'UnitMass' to expected argument type 'UnitLength'
</code></pre>
<p>The same applies for unit conversions, in which units conforming to the <code>Dimension</code> type can only convert to units in the same domain.</p>
<pre><code class="language-swift">var weight = Measurement(value: 52, unit: UnitMass.kilograms)
weight.converted(to: .grams) // ‚úÖ 52_000 g
weight.converted(to: .liters) // üõë Type 'UnitMass' has no member 'liters'
</code></pre>
<h3>Easy Extensibility</h3>
<p>Given their origins as Objective-C types, <code>Unit</code> and <code>Dimension</code> are abstract classes used as the base for the unit systems, implementing new unit types or dimensions via subclassing.</p>
<pre><code class="language-swift">class Amount: Dimension, @unchecked Sendable {
    static var units: Self { .init(symbol: &quot;u&quot;) }
}

class Force: Dimension, @unchecked Sendable {
    static var newtons: Self { .init(symbol: &quot;N&quot;) }
}
</code></pre>
<p>And, through the use of extensions, you can also add brand new units like shown above, but also create entirely new units, being specifically useful when your app or game has a custom set of context-relevant units to measure it‚Äôs information.</p>
<pre><code class="language-swift">public extension UnitLength {
    static var gizaPyramids: Self {
		.init(symbol: &quot;‚ó¢‚ó£&quot;, converter: UnitConverterLinear(coefficient: 146.6, constant: 0))
	}
}
</code></pre>
<h3>Formatting and Display</h3>
<p>When you want to display a measure, Foundation automatically formats your unit based on the device‚Äôs settings (locale, metric system, etc.). You can also configure it‚Äôs display format through the <code>formatted()</code> instance method on <code>Measurement</code>, which uses a DotSyntax <code>.measurement</code> to create an instance of <code>FormatStyle</code> dedicated to the Measurement API:</p>
<pre><code class="language-swift">let volume = Measurement(value: 10, unit: UnitVolume.cubicFeet)
volume.formatted() // &quot;283.168 cm¬≥&quot;
volume.formatted(.measurement(width: .wide)) // &quot;283.168 cubic centimetres&quot;
volume.formatted(.measurement(width: .narrow, usage: .asProvided)) // 10ft¬≥&quot;
volume.formatted(.measurement(width: .abbreviated, usage: .liquid, numberFormatStyle: .number)) // &quot;283 l&quot;
</code></pre>
<h3>Wide Assortment of Default Units</h3>
<p>By default, Foundation provides over 22 specializations of <code>Unit</code> and/or <code>Dimension</code> (which amounts to over 200 predefined units), all with included formatting and display options for select unit types.</p>
<blockquote>
<p>üîÆ <strong>Fun Fact</strong>: As of writing, the most recent unit added to the Measurement API is <a href="https://developer.apple.com/documentation/foundation/unitenergy/energykit/milliwatthours">milliwattHours</a>, a unit of energy added in OS 26 and meant for use with the brand new <a href="https://developer.apple.com/documentation/EnergyKit">EnergyKit</a>‚Ä¶ yet the unit is not available for watchOS, tvOS or visionOS and has it‚Äôs own subtype inside of <code>UnitEnergy</code> (<code>UnitEnergy.EnergyKit</code>)</p>
</blockquote>
<p>This gives developers an out-of-the-box solution for most use cases that a traditional app would require. Add this with the easy extensibility for new and existing unit types and you have an API that‚Äôs user-friendly, battle-tested and well designed for most developer needs.</p>
<p>Except‚Ä¶</p>
<h2>Limitations</h2>
<p>Well, as mentioned in the description of this post, there are some limitations that make the Measurement API not reach it‚Äôs full intended potential when looking at it from the perspective of a Swift package.</p>
<h3>Objective-C constraints</h3>
<p>The current implementation in Swift is a Objective-C implementation into the language, sharing the same logic as the original module: with this, comes some important considerations before using it.</p>
<p>For starters, there‚Äôs no compile-time enforcement stopping you from instancing <code>Unit</code> and <code>Dimension</code> objects in your code, or using them as <code>Measurement</code> filters, completely breaking the type-safety of the generic type. For example, the snippet below compiles and runs just fine with no errors:</p>
<pre><code class="language-swift">var generalMeasurement = Measurement(value: 32, unit: Unit(symbol: &quot;#&quot;))
generalMeasurement = Measurement(value: 22, unit: UnitArea.ares)
generalMeasurement = Measurement(value: 89, unit: UnitInformationStorage.bits)
</code></pre>
<p>You could even attempt to encode and decode the measurement under a generic measurement:</p>
<pre><code class="language-swift">var gameSize = Measurement(value: 40, unit: UnitInformationStorage.bits)
let encoded = try JSONEncoder().encode(gameSize)
var decoded = try JSONDecoder().decode(Measurement&lt;UnitInformationStorage&gt;.self, from: encoded)
decoded = Measurement(value: 20, unit: UnitPower.watts) // üõë Cannot convert value of type 'UnitPower' to expected argument type 'UnitInformationStorage'
var decodedWithGeneric = try JSONDecoder().decode(Measurement&lt;Unit&gt;.self, from: encoded)
decodedWithGeneric = Measurement(value: 20, unit: UnitPower.watts)
</code></pre>
<p>This could also lead to crashes at runtime, as the compiler‚Äôs type inference isn‚Äôt able to identify that these are two different types of <code>Measurement</code>, with the code below compiling just fine and presenting an error at runtime:</p>
<pre><code class="language-swift">var path = Measurement(value: 32, unit: UnitLength.kilometers)
var surface = Measurement(value: 21, unit: UnitArea.squareMiles)
path &lt; surface // üõë Fatal error: Attempt to compare measurements with non-equal dimensions
</code></pre>
<p>Even when accounting for <code>Comparable</code> and rewriting as <code>Measurement&lt;Unit&gt;</code> instances provides the same results:</p>
<pre><code class="language-swift">var path2 = Measurement&lt;Unit&gt;(value: 32, unit: UnitLength.kilometers)
var surface2 = Measurement&lt;Unit&gt;(value: 21, unit: UnitArea.squareMiles)
path2 &lt; surface2 // üõë Fatal error: Attempt to compare measurements with non-equal dimensions
</code></pre>
<p>Add in the Strict Concurrency Model, and even such a simple operation as this:</p>
<pre><code class="language-swift">func someOperation(_ measurement: Measurement&lt;UnitLength&gt;) -&gt; UnitLength {
    return measurement.unit
}

var height = Measurement(value: 1.82, unit: UnitLength.meters)
let outcome = someOperation(height) // ‚úÖ No issues
</code></pre>
<p>Can have issues at runtime by adding a single <code>async</code>, even if the method has no suspend points:</p>
<pre><code class="language-swift">func someOperation(_ measurement: Measurement&lt;UnitLength&gt;) async -&gt; UnitLength {
    return measurement.unit
}

var height = Measurement(value: 1.82, unit: UnitLength.meters)
let outcome = await someOperation(height) // üõë error: execution stopped with unexpected state.
</code></pre>
<p>Even properly constraining the method to <code>@MainActor</code> as per requirement of a type inheriting from <code>NSObject</code> causes the same issue as above.</p>
<p>Dealing with an Objective-C class in Swift can be a very complex challenge already for developers with years of Swift experience given the Strict Concurrency requirements, so moving on to a pure Swift implementation in the future already will reduce many of the headaches listed above.</p>
<p>All of the above is temporary, up until a pure Swift implementation arrives, but there are some other things that</p>
<h3>Not SI compliant</h3>
<p>Another downside to the current implementation lies in it‚Äôs default set of physical dimensions available, which does not encapsulate all SI units.</p>
<p>While there‚Äôs 22 unit types provided with the package, only 5 of the 7 fundamental units are contemplated: Time (under <code>UnitDuration</code>). We also have a pretty big omission with Force not being an actual specialization in the package given it‚Äôs pretty useful role in Physics operations, being the basis to compose other already implemented dimensions such as <code>UnitEnergy</code> and <code>UnitPressure</code>.</p>
<p>While the Measurement API has over 200 defined units, a sizeable number of them are just a redeclaration of the same unit under a different metric prefix and an adjusted converter to account for the new value. If we want any new unit system to follow SI‚Äôs metric prefix conventions, we require to implement <em><strong>over 10 definitions per defined unit that we want to support Metric Prefixes on.</strong></em></p>
<blockquote>
<p>For reference, while <code>UnitInformationStorage</code> has by far the most amount of defined units in Foundation, the actual meaningful number of units for the domain are 3: <code>bit</code>, <code>nibble</code> and <code>byte</code>. This is due to the fact it not only implements SI‚Äôs metric prefixes for <code>bit</code> and <code>byte</code>, but also a <a href="https://en.wikipedia.org/w/index.php?title=Binary_prefix">Binary Prefix</a>.</p>
</blockquote>
<h3>Restrictive API</h3>
<p>While the API is pretty robust and well-designed, there are some obstacles that could be patched up to provide a more accurate and flexible behaviour.</p>
<p>One example of this is when creating a <code>Measurement</code> instance: while <code>Measurement</code> accepts any <code>Double</code> value, there are cases where constraining the value to another type would allow for more accurate representation in context (e.g. describing a file size using <code>Int</code> or <code>Decimal</code> in order to avoid floating-point errors or provide discrete measurement of units).</p>
<p>While the API itself is pretty descriptive and easy to understand by reading the code, it can also become pretty verbose: creating a variable to store a measure of ‚Äú2m‚Äù can require 54 characters in it‚Äôs smallest, non-explicit form, as shown below:</p>
<pre><code class="language-swift">var x = Measurement(value: 2, unit: UnitLength.meters)
</code></pre>
<p>Speaking of less-verbose syntax, another issue lies in the lack of DotSyntax support for units, which is a result of <code>Unit</code>, <code>Dimension</code> and it‚Äôs inherited types defined in the packages being non-generic, non-<code>final</code> classes.</p>
<pre><code class="language-swift">final class CustomLength: UnitLength, @unchecked Sendable {
    static var palms: Self { .init(symbol: &quot;‚úã&quot;) }
}

let failedDotSyntax1 = Measurement&lt;Unit&gt;(value: 23, unit: .palms) // üõë Type 'Unit' has no member 'palms'
let failedDotSyntax2 = Measurement&lt;UnitLength&gt;(value: 23, unit: .palms) // üõë Type 'UnitLength' has no member 'palms'
let validDotSyntax = Measurement&lt;CustomLength&gt;(value: 23, unit: .palms) // ‚úÖ Success
</code></pre>
<p>The implementation above still requires explicit declaration of generics, which limits the permisiveness of the notation.</p>
<p>Some other drawbacks include being unable to create ranges of measures with units conforming to <code>Dimension</code> and using a <code>UnitConverterLinear</code> and converting to derived units using the base operations (e.g. <code>Measurement&lt;UnitLength&gt;</code> * <code>Measurement&lt;UnitLength&gt;</code> = <code>Measurement&lt;UnitArea&gt;</code>).</p>
<p>There‚Äôs probably more examples I could talk about, but overall the API has some areas of improvement so that it can become less diffuse, more visible and permissive.</p>
<h2>Conclusion</h2>
<p>As with any framework design, there‚Äôs no absolutes on what is better and the current design of swift-foundation already is pretty great and works for most of use cases that a developer would need in their day-to-day, only requiring a pure Swift implementation to fix most of it‚Äôs issues.</p>
<p>Due to ABI and source stability requirements it‚Äôs unlikely that we‚Äôll see any big redesign to the current code as it is required to be compatible with the current Foundation. However, we can look into Swift packages made by the community for alternatives made with modern features in mind:</p>
<ul>
<li><a href="https://github.com/alexandrehsaad/swift-measures">swift-measures</a> is a very good reimplementation of the Measurement API that takes advantage of Swift features, such as structs, protocols and property wrappers. It also dips into new features like the composition of measures (e.g. Length / Time = Velocity) and adds in missing SI unit types such as Force, Magnetic Flux, Substance Amount and more.</li>
<li><a href="https://github.com/hyperjeff/Physical">Physical</a> goes for an unique approach: it builds on top of the current Foundation structure, composing units by chaining numbers with properties and mixing dimensions to create new ones using a base <code>Physical</code> protocol.</li>
<li><a href="https://github.com/NeedleInAJayStack/Units">Units</a> also follows a similar approach to the packages above, creating it‚Äôs own implementation for composing units together, using a registry system to parse a measurement from a <code>String</code>. The package also provides a CLI tool for use in conversions.</li>
<li>Beyond these, I‚Äôm also working on my <a href="https://github.com/MartonioJunior/trinkets-swift">own implementation</a> of Units and Measurements for Game Development purposes, focusing more on ergonomy, type-safety, generics and other Modern Swift features (e.g. Integer Generic Parameters) to provide a more structured approach for units that aids experimentation and prevents bugs and misuses at compile time.</li>
</ul>
<p>At the end of the day, the best approach is the one that actually fits the requirements of your software, so choosing the right tool for the job (or even implementing your own based on existing solutions) is the way to go.</p></div></article></div><footer><p>¬© 2025 Mart√¥nio J√∫nior</p><p>Website built in Swift using <a href="https://github.com/coenttb/swift-html">swift-html</a> and <a href="https://github.com/loopwerk/Saga">Saga</a></p><p><a href="/feed.rss">RSS</a> | <a href="https://github.com/martoniojunior">Github</a></p></footer><link rel="stylesheet" integrity="sha384-//SZkxyB7axjCAopkAL1E1rve+ZSPKapD89Lo/lLhcsXR+zOYl5z6zJZEFXil+q0" href="https://cdn.jsdelivr.net/npm/katex@0.16.23/dist/katex.min.css" crossorigin="anonymous"><script crossorigin="anonymous" integrity="sha384-cpAIxua0Xbyc+XrpHQpCtJzGSZ6U2kS/FeyoKjnS+BgAYNV6uVUetVs/LC9+l3rs" defer src="https://cdn.jsdelivr.net/npm/katex@0.16.23/dist/katex.min.js"></script><script onload="renderMathInElement(document.body, {&quot;delimiters&quot;:[{&quot;display&quot;:true,&quot;left&quot;:&quot;$$&quot;,&quot;right&quot;:&quot;$$&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\(&quot;,&quot;right&quot;:&quot;\\)&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{equation}&quot;,&quot;right&quot;:&quot;\\end{equation}&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{align}&quot;,&quot;right&quot;:&quot;\\end{align}&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{alignat}&quot;,&quot;right&quot;:&quot;\\end{alignat}&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{gather}&quot;,&quot;right&quot;:&quot;\\end{gather}&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{CD}&quot;,&quot;right&quot;:&quot;\\end{CD}&quot;},{&quot;display&quot;:true,&quot;left&quot;:&quot;\\[&quot;,&quot;right&quot;:&quot;\\]&quot;},{&quot;display&quot;:false,&quot;left&quot;:&quot;$&quot;,&quot;right&quot;:&quot;$&quot;}]});" crossorigin="anonymous" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" defer src="https://cdn.jsdelivr.net/npm/katex@0.16.23/dist/contrib/auto-render.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/default.min.css"><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/csharp.min.js"></script><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/swift.min.js"></script><script>hljs.highlightAll();</script></body></html>
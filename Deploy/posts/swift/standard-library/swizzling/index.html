<!doctype html><html><head><title>Arts, Blueprints, Code!</title><meta charset="utf-8"><link type="text/css" rel="stylesheet" href="/Resources/EnergyTheme/styles.css"><link type="text/css" rel="stylesheet" href="/Resources/EnergyTheme/code.css"><style></style></head><body><header><div class="wrapper"><a class="site-name" href="/">Arts, Blueprints, Code!</a><p class="description">Talking the ABC of Programming, Game Dev, Design and more by Mart√¥nio Jr.</p><p class="wip">Website still in development...</p><nav><ul><li class><a href="/posts">Posts</a></li><li class><a href="/projects">Projects</a></li><li class><a href="/artsCrafts">Arts and Crafts</a></li><li class><a href="/web">Surfing the Web</a></li><li class><a href="/about">About</a></li><li class><a href="/contact">Contact</a></li></ul></nav></div></header><div class="wrapper"><article><h1>Swizzling SIMD in Modern Swift</h1><p class="description">Combining `KeyPath` and `InlineArray` to improve `SIMD` types and applying the concept beyond</p><p class="timestamps">Posted <time datetime="30/09/2025, 10:40">30 de set. de 2025, 10:40</time>, Last Updated <time datetime="03/11/2025, 18:22">3 de nov. de 2025, 18:22</time></p><div class="content"><h2>Introduction</h2>
<p>Swizzling is the act of transforming vectors by rearranging it‚Äôs components to create new vectors with components swapped around or even projected into another dimensionality. It‚Äôs most commonly used in computer graphics and games to quickly form new data structures using it‚Äôs components, with a less verbose approach for initialization.</p>
<pre><code class="language-csharp">// Example of Vector Swizzling using C#
Vector3 a = Vector3(8, 3, 4)
Vector3 b = a.yzx // (3, 4, 8)
Vector2 c = a.xz // (8, 4)
Vector3 d = a.xoy // (8, 0, 4)
</code></pre>
<p>Usually, to implement swizzling of a type, such as a vector or a matrix, usually requires implementing all of the possible cases as methods or properties in the type itself to allow the syntax you see above. However, it can be a pretty tedious and time-consuming process to implement them if the type you‚Äôre using doesn‚Äôt already support it.</p>
<blockquote>
<p>üîÆ Always check if someone hasn‚Äôt already made the hard work already! If not, you really only need to implement this once and reuse in whenever project you require.</p>
</blockquote>
<p>To give you an idea of how consuming this can be, implementing a Swizzling operation manually for a non-descriptive <code>Vector</code> type of size $n$ converting to a target <code>Vector</code> of size $t$ can be defined by the following function:<br />
$$f(n, t) = (n+1)^t$$<br />
where $n+1$ describes every component of a vector, plus the definition of $0$ used to erase a component‚Äôs value in certain operations that require it (e.g. moving a 3D character in a 2D plane).</p>
<p>This means that, to implement swizzling from a type to create a <code>Vector2</code>, <code>Vector3</code> and <code>Vector4</code>, it‚Äôd require:</p>
<ul>
<li>$3^2 + 3^3 + 3^4 = 9 + 27 + 81 = 117$ members in <code>Vector2</code></li>
<li>$4^2 + 4^3 + 4^4 = 16 + 64 + 256 = 336$ members in <code>Vector3</code></li>
<li>$5^2 + 5^3 + 5^4 = 25 + 125 + 625 = 775$ members in <code>Vector4</code></li>
</ul>
<p>That‚Äôs a lot! And it doesn‚Äôt even factor in:</p>
<ul>
<li>How many lines of code you have to maintain: if we count each member as a line of code as a generous guideline, we‚Äôd have <em><strong>1228 members</strong></em> in total!
<ul>
<li>Even separating each type to a single file dedicated to Swizzling, some linters‚Äô default rules like swift-lint would mark an error for the <code>SIMD3</code> and <code>SIMD4</code> extensions</li>
</ul>
</li>
<li>The number of test methods required to check each property: even if you bulk them all in a single test method, it‚Äôd still be 1228 parameters to maintain.</li>
<li>Adding support to Vectors with other dimensions, which would add the members of itself and new members to all vectors that already implemented swizzling.</li>
<li>Matrices! Yeah, we forgot about those‚Ä¶</li>
</ul>
<h2>SIMD Swizzling in Swift</h2>
<blockquote>
<p>‚ÑπÔ∏è Not to be confused with another definition of ‚ÄúSwizzling‚Äù commonly used in the Swift language, which is about replacing methods from Objective-C with a Swift version.</p>
</blockquote>
<p>A lot of the work described above comes from the fact we need to define every arrangement of a component to the size of every target vector. So we just implement a method or subscript that receives the components and returns the swizzled vector, right? That‚Äôs what <code>SIMD</code> does!</p>
<pre><code class="language-swift">// Snippet of SIMD's implementation in Swift
// Source: https://github.com/swiftlang/swift/blob/main/stdlib/public/core/SIMDVector.swift

@_alwaysEmitIntoClient
public subscript&lt;Index&gt;(index: SIMD2&lt;Index&gt;) -&gt; SIMD2&lt;Scalar&gt; where Index: FixedWidthInteger {
	var result = SIMD2&lt;Scalar&gt;()
	for i in result.indices {
	  result[i] = self[Int(index[i]) % scalarCount]
	}
	return result
}
</code></pre>
<p>That looks a lot better than creating all members by hand since you only have one method per type and since this is implemented as a <code>SIMD</code> extension, it can be used by all types conforming to the protocol. Yet we lost a few things along the way:</p>
<ul>
<li>Access to the components now happen through indices, which now need to be validated before usage (and in <code>SIMD</code>‚Äòs case, it doesn‚Äôt protect against negative values unless <code>Index</code> is an unsigned integer)</li>
<li>It describes components as integers, reducing the role-expressiveness that once came from accessing the swizzled vector by typing it‚Äôs components: you still have knowledge of the role of each index, but that now requires an extra cognitive step of associating it with the component it represents.</li>
<li>There‚Äôs no way to reference a default value (e.g. $0$, $1$) while swizzling, meaning that <code>Index</code> does not encapsulate all possible swizzling</li>
</ul>
<p>Beyond the above, every implementation repeats the exact same code as above, only replacing the data structures for <code>Index</code> and the return type.<br />
But what if I told you we can fix all of the issues above and define it all with a single implementation?</p>
<h2><code>KeyPath</code> to the Rescue!</h2>
<blockquote>
<p>üí¨ Due to performance reasons or limitations in a language or a dev stack environment, implementing swizzling via methods and properties may still be the most effective approach. The approach I‚Äôm about to show is focused on flexibility and ease of use first and foremost.</p>
</blockquote>
<p>With <code>[KeyPath]</code>, we can now create back a swizzled <code>[Scalar]</code> with any size that, while still a bit more verbose  than a member-based approach, it‚Äôs safer and maintains the same role-expressiveness as the standard approach:</p>
<pre><code class="language-swift">public extension SIMD {
	subscript(swizzle swizzle: KeyPath&lt;Self, Scalar&gt;...) -&gt; [Scalar] {
		swizzle.map { self[keyPath: $0] }
	}
}

// Performing a Swizzle with KeyPath
var vector = SIMD3(x: 3, y: 2, z: 5)
var swizzled: SIMD3&lt;Int&gt; = .init(vector[swizzle: \.x, \.y, \.x]) // [3, 2, 3]
</code></pre>
<p><em>‚ÄúBut wait, <code>@dynamicMemberLookup</code> would allow the swizzling syntax to be the standard one, no?‚Äù</em><br />
In theory, yes, but that comes with some implications:</p>
<ul>
<li>You are in control of the type, marked <code>@dynamicMemberLookup</code> and declared <code>subscript(dynamicMember:)</code> on it‚Äôs original module, which is not possible with <code>SIMD</code> given it‚Äôs part of the standard library and you cannot add <code>@dynamicMemberLookup</code> support from an extension.</li>
<li>The storage of a data structure allowing constant-time access to it‚Äôs components, else you need to parse the <code>String</code> into separate characters, then mapping each to it‚Äôs respective component (when you can even map to it).</li>
<li>Working with <code>String</code> brings back the problem of invalid indices, which would require fallback checks using <code>precondition</code> or return of an <code>Optional</code> type for the component vs a compile-time guarantee for the swizzled result</li>
</ul>
<p>While <code>SIMD</code> does not have a valid key path to a $0$, you can add one via an extension. However, there is a better approach as we can use <code>KeyPath</code> in functions since Swift 5.2. Therefore, we can reimplement it as follows, without changing how it is used:</p>
<pre><code class="language-swift">public extension SIMD {
	subscript(swizzle swizzle: (Self) -&gt; Scalar...) -&gt; [Scalar] {
		swizzle.map { $0(self) }
	}
}

// Performing a Swizzle with KeyPath and Functions
var vector = SIMD3(x: 3, y: 2, z: 5)
var swizzled: SIMD3&lt;Int&gt; = .init(vector[\.x, \.y, { _ in .zero}]) // [3, 2, 0]
</code></pre>
<blockquote>
<p>üîÆ You can also create a global function to simplify the process of writing in these closures:</p>
</blockquote>
<pre><code class="language-swift">public func always&lt;each T, U&gt;(_ value: @autoclosure @escaping () -&gt; U) -&gt; (repeat each T) -&gt; U {
	{ (_: repeat each T) in value() }
}

// Performing a Swizzle with KeyPath, Functions and always(_:)
var vector = SIMD3(x: 3, y: 2, z: 5)
var swizzled: SIMD3&lt;Int&gt; = .init(vector[always(1), \.z, always(.zero)]) // [1, 5, 0]
</code></pre>
<p>We finally are able to swizzle around of components, but we still have some issues: we have no way of guaranteeing that the size of <code>[Scalar]</code> actually corresponds to the <code>SIMD</code> we‚Äôre planning to initialize, as it does not warn at compile-time about a size-mismatch and invokes a precondition failure at runtime.</p>
<p>For that, we‚Äôd need to have a guarantee that the data structure we‚Äôre returning always has the same size as the <code>SIMD</code> we‚Äôd want to output or directly return the <code>SIMD</code> that we want, which would both require us to go back to having a method per type, with  <code>swizzle</code>  having a different definition for each one while mostly repeating the same implementation.</p>
<p>If you‚Äôre using Swift 6.1 or earlier, this is where we stop in implementing swizzling, but thanks to <code>InlineArray</code> and Integer Generic Parameters in Swift 6.2, we can actually not only fix this, but even build an approach greater than the current <code>SIMD</code> types we have available.</p>
<h2>Adding in <code>InlineArray</code></h2>
<p>New to Swift, <code>InlineArray</code> is a collection (though it does not conform to <code>Collection</code> yet) of non-copyable types that you can use to define inline fixed-size arrays, with the size defined as part of the generic type declaration. This means that we can have compile-time guarantees about the size of the array we use on <code>SIMD</code> and that initialization will always be successful.</p>
<p>Unfortunately, that will require us to still write some boilerplate to allow this to happen, as each <code>SIMD</code> concrete type will need an initializer to accept an inline array with the same size as itself:</p>
<pre><code class="language-swift">public extension SIMD3 {
	init(_ inline: [3 of Scalar]) {
		self.init(x: inline[0], y: inline[1], z: inline[2])
	}
}

// Initializing a Swift from an InlineArray
var simdA = SIMD3&lt;Int&gt;([1, 2, 3]) // ‚úÖ
var simdB = SIMD3&lt;Int&gt;([1, 2, 3, 5, 6]) // üõë Cannot convert value of type '[5 of Int]' to expected argument type '[3 of Int]'
var simdC = SIMD3&lt;Int&gt;([1]) // üõë Cannot convert value of type '[1 of Int]' to expected argument type '[3 of Int]'
</code></pre>
<p>Then, we can change the implementation of <code>subscript(swizzle:)</code> to the following:</p>
<pre><code class="language-swift">public extension SIMD {
	subscript&lt;let N: Int&gt;(_ swizzle: [N of (Self) -&gt; Scalar]) -&gt; [N of Scalar] {
		.init { swizzle[$0](self) }
	}
}

// Creating a new SIMD out of a Swizzle
var vector = SIMD3(x: 3, y: 2, z: 5)
var swizzled = vector[[\.x, always(6), \.x]] // [3, 6, 3]
var newSimd = SIMD3(swizzled) // SIMD3(x: 3, y: 6, z: 3)
</code></pre>
<h2>‚ÄúSwizzling‚Äù everything‚Ä¶</h2>
<p>However, we can still go further with swizzling using the ideas shown above:</p>
<h3>Custom <code>SIMD</code> + Integer Generic Parameters = <code>Vector</code></h3>
<p>As the <code>SIMD</code> implementations in the standard library are all concrete types with no generic integer parameters, we need to implement initializers for each type in order to transform the inline array back into a SIMD type. However, by creating a custom structure that conforms to <code>SIMD</code> protocol, you can create a custom type that takes advantage of <code>InlineArray</code> and <code>SIMD</code>:</p>
<pre><code class="language-swift">@available(macOS 26.0, *)
public struct Vector&lt;let N: Int, Scalar&gt; {
	var elements: [N of Scalar]

	public subscript(_ index: Int) -&gt; Scalar {
		get { elements[index] }
		set { elements[index] = newValue }
	}

	public init(_ elements: [N of Scalar]) {
		self.elements = elements
	}
}

@available(macOS 26.0, *)
extension Vector: SIMD where Scalar: SIMDScalar &amp; AdditiveArithmetic {
	public typealias MaskStorage = Vector&lt;N, Scalar.SIMDMaskScalar&gt;
}

@available(macOS 26.0, *)
extension Vector: SIMDStorage where Scalar: AdditiveArithmetic &amp; Codable &amp; Hashable {
	public var scalarCount: Int { count }

	public init() {
		self.init(.init(repeating: .zero))
	}
}
</code></pre>
<p>Now we can return the swizzled type created directly instead of just an <code>InlineArray</code>:</p>
<pre><code class="language-swift">@available(macOS 26.0, *)
public extension Vector {
	subscript&lt;let A: Int&gt;(_ swizzle: [A of (Self) -&gt; Scalar]) -&gt; Vector&lt;A, Scalar&gt; {
		.init(InlineArray { swizzle[$0](self) })
	}
}

// Creating a new Vector out of a swizzle
var vector = Vector([3, 2, 5]) // Vector&lt;3, Int&gt;
var swizzled = vector[[\.x, always(6), \.x]] // Vector&lt;3, Int&gt;([3, 6, 3])
</code></pre>
<h3>Feature Extraction (<code>extract(_:features:)</code>)</h3>
<p>Another road one can take is to forego the traditional ideas of <code>SIMD</code> and use <code>KeyPath</code> and <code>InlineArray</code> to extract property values out of a type directly and return it in a structured manner:</p>
<pre><code class="language-swift">@available(macOS 26.0, *)
public func extract&lt;Element, let A: Int, T&gt;(_ element: Element, features: [A of (Element) -&gt; T]) -&gt; [A of T] {
	features.map { $0(element) }
}
</code></pre>
<p>Combine this with a <code>Sequence</code> or <code>Collection</code> type and you have a flexible method to extract values directly, although it is limited to all items belonging to the same type</p>
<pre><code class="language-swift">var vector = [&quot;goal&quot;, &quot;apple&quot;, &quot;bananas&quot;]
var elements = extract(vector, features: [\.[0], \.[2]])
</code></pre>
<blockquote>
<p>üîÆ While the ideal approach for the method would be to use variadic generics, this is not possible here due to the lack of a fixed-size heterogeneous data structure that is able to maintain the type-safety of it‚Äôs properties (<del>sounds like a future post idea if I‚Äôve ever seen one</del>).</p>
</blockquote>
<h2>Conclusion</h2>
<p>While swizzling can be pretty easy to grasp as a concept, implementing it can be a pretty challenging experience for developers, as we need to take into account performance, ease of use and flexibility when choosing them. By using clever abstractions and some modern language features, we can take features that already exist in Swift and combine them into more powerful and efficient types that can be used even in situations outside of it‚Äôs intended purpose to make code that feels good to write while maintaining important guarantees to strengthen our codebase.</p></div></article></div><footer><p>¬© 2025 Mart√¥nio J√∫nior</p><p>Website built in Swift using <a href="https://github.com/coenttb/swift-html">swift-html</a> and <a href="https://github.com/loopwerk/Saga">Saga</a></p><p><a href="/feed.rss">RSS</a> | <a href="https://github.com/martoniojunior">Github</a></p></footer><link rel="stylesheet" integrity="sha384-//SZkxyB7axjCAopkAL1E1rve+ZSPKapD89Lo/lLhcsXR+zOYl5z6zJZEFXil+q0" href="https://cdn.jsdelivr.net/npm/katex@0.16.23/dist/katex.min.css" crossorigin="anonymous"><script crossorigin="anonymous" integrity="sha384-cpAIxua0Xbyc+XrpHQpCtJzGSZ6U2kS/FeyoKjnS+BgAYNV6uVUetVs/LC9+l3rs" defer src="https://cdn.jsdelivr.net/npm/katex@0.16.23/dist/katex.min.js"></script><script onload="renderMathInElement(document.body, {&quot;delimiters&quot;:[{&quot;right&quot;:&quot;$$&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;$$&quot;},{&quot;right&quot;:&quot;\\)&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\(&quot;},{&quot;right&quot;:&quot;\\end{equation}&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{equation}&quot;},{&quot;right&quot;:&quot;\\end{align}&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{align}&quot;},{&quot;right&quot;:&quot;\\end{alignat}&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{alignat}&quot;},{&quot;right&quot;:&quot;\\end{gather}&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{gather}&quot;},{&quot;right&quot;:&quot;\\end{CD}&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\begin{CD}&quot;},{&quot;right&quot;:&quot;\\]&quot;,&quot;display&quot;:true,&quot;left&quot;:&quot;\\[&quot;},{&quot;right&quot;:&quot;$&quot;,&quot;display&quot;:false,&quot;left&quot;:&quot;$&quot;}]});" crossorigin="anonymous" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" defer src="https://cdn.jsdelivr.net/npm/katex@0.16.23/dist/contrib/auto-render.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/default.min.css"><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/csharp.min.js"></script><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/swift.min.js"></script><script>hljs.highlightAll();</script></body></html>